
These should be added to the GForge site of the project. :)

================================================================================

Setting arguments for queries
-----------------------------

Query#setArgument(int number, Object value);

================================================================================

Improving the syntax of queries
-------------------------------

Queries can be passed to provers as strings that store ISO Prolog goals. In the 
goal the name of the variables can be suffixed by braces that bind the value of
the corresponding formal argument to the variable.

E.g.:
prover.solve("member(X{}, List{}).", 1, Arrays.asList(1, 2, 3))

The first formal argument (1) following the query will be bound to the first 
variable denoted by braces (X), the second argument ([1, 2, 3]) to the second 
such variable (List) and so on. At most one occurrence of a variable needs to
be supplemented by braces. This notation is suitable for input variables.

However, the names of the output variables are also needed. Since the solutions
are iterable objects themselves, they need the name of a variable, whose values
can be returned by their iterator. This is called the default output variable. 
Moreover, there are methods for collecting all solutions. These methods need the
name of each output variable.

For now, all the variables occurring in the query are regarded as output vari-
ables, and the default output variable is the one last occurring in the goal.
However, this is not a flexible solution.

The following notation is suggested in accordance with the convention for Prolog
documentations:
  - input variables: {} or {+}
  - output variables: {-}
  - input/output variables: {?}
  - input variables that must be bound: {@}
  - local variables are not denoted.

Scheduled for 0.1.2

================================================================================

Alternatives to the syntax extension of queries
-----------------------------------------------

1) return/1

The default output variable could be specified by the return/1 predicate. The 
predicate could be used only at the end of the query, and it should be automati-
cally removed from the query, remembering its argument. If the argument is a 
variable then it will be the default output variable. If not then a new variable
should be introduced and that will be the default output variable.

E.g.:
return(X) should be removed or replaced by true
return([1, 2 | X]) should be replaced by NewVar = [1, 2 | X]

This can be easily done for any implementation by using a visitor on the parsed
query. The visitor should look for the rightmost return node of the parsed 
query.

2) Collect methods

These methods should accept a list of variables whose values they have to 
collect.

Scheduled for 0.1.2

================================================================================

Alternative implementations
---------------------------

Alternative implementations should be developed for CIAO Prolog, SWI-Prolog and
so on.

Not of high priority.

================================================================================

Refactorings, clean-ups
-----------------------

Add missing JavaDoc comments, improve the code style according to the checkstyle
plugin.

Scheduled for 0.2.0

================================================================================

JUnit tests
-----------

Much more tests needed. Cobertura may help to find the weaknesses.

Scheduled for 0.2.0

================================================================================

Prolog4J site
-------------

When the site is ready, 

Scheduled for 0.2.0

================================================================================

Annotation framework
--------------------

The annotation framework provides simple annotations for defining Java 
interfaces for goals. Such an interface is a method annotated by @Goal. The 
formal arguments and the return type of the method can be annotated by @In, 
@Out, @InOut and @NonNull.

Annotations can be used for static type checking and code generation as well.

See below.

================================================================================

Static type checking
--------------------

The checks which can be performed:
  - check the "format string" against the argument types.
  - check the requested variable name (if specified by a literal) against the 
    expected type.
    e.g. aGoalMethod().<String>on("X")
  - ???

================================================================================

Generating goal method body
---------------------------

Goal methods contain only the invocation of the prover. Normally the prover 
associated to the class is to be used, however, the name of the prover should be
able to be specified as the argument of @Goal.

It should be possible to use a quasi empty method body (e.g. throw null;). In 
this case, the invocation of the Prover can be generated at compile time if the 
Sun Java compiler is used. If not, the body can be generated at load time.

The preferred way is to generate them at load-time by a Java agent.

================================================================================

Theories
--------

Theories can be specified by the @Thery specification on types or packages. The 
theory will be added to the prover associated to that type or package, respecti-
vely. Theories should be loaded automatically. The code that adds the theory to 
the appropriate prover can be generated at compile-time if the Sun Java compiler
is used. If not, the theory can be added to the prover at load-time.

The preferred way of loading theories is to load them at the load-time of the 
class or package by a Java agent.

================================================================================

Terms
-----

Term classes can be specified by @Term. The instances of term classes should be 
able to be converted to terms automatically. The way of this should still be 
elaborated. Similarly, if the functor of a compound term equals the name of a 
term class (or the argument of @Term) then the term will be converted to an 
instance of the class. Also, the way of this should be elaborated.
