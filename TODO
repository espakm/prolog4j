
These should be added to the GForge site of the project. :)

================================================================================

Passing input arguments to goals
--------------------------------

Now several ways are provided for passing initial values for the variables:
 - parallel arrays of variable names and values (String[], Object[])
 - a mapping of variable names to values (Map<String, Object>)
 - no variable names are passed, only their values:
   the goal is supposed to be a single compound term whose arguments are the 
   names of the variables
   
The first two solution is not convenient and the third one is not flexible. 
Moreover, the preferred type to which the output variable cannot be specified. 
Instead, one of the following notations should be used:

 - Java formatter notation.
   E.g. V%s
 - C#-like notation. This is used in SLF4J as well.
   E.g. {V}

Either of the notations should be capable of the followings:
 - the name of the variable
 - the type of the variable (expected type for inputs, suggested type for outputs)
 - the purpose of the variable: input, output, input/output, input and bound

Moreover, these informations are not needed to be specified for each variables. 
At default, the values are specified in the order of the occurrence of the 
variables. If you would not like to bind an initial value for an argument, you
can pass null to it. At default, the last variable should be the default output
argument.

================================================================================

Queries as a separate class
---------------------------

A Query represents a Prolog goal that can be parameterized and can be solved by 
a Prover resulting a Solution. Normally, a query can be solved by a prover at 
any time, for different sets of actual arguments.

Queries are similar to the Statement and PreparedStatement class of JDBC.

For now, queries are not represented as a separate type. A query is stored as an
array of terms where the first term represents the query itself and the rest of
the arguments represent the input variables inside the query.  

Probably it is worth to distinguish a Query and a PreparedQuery type.

================================================================================

Hierarchy of provers associated to package and class names
----------------------------------------------------------

Provers have to be assigned to (and accessed by) a name. Normally, the class or 
package names should be used for accessing the prover of the given class or
package, but arbitrary names can be used. Provers are created dynamically at the
first time they are requested. (This is similar to the way of accessing loggers 
in logging frameworks.)

================================================================================

Service Provider Interface pattern
----------------------------------

The Prover, Query and Solution types should be abstract, and their 
implementations should be accessed through a factory. This is similar to the way
of SLF4J for creating loggers. 

The suitable implementation should be able to be selected at deployment time.

================================================================================

Alternative implementations
---------------------------

Alternative implementations of should be developed for jTrolog, JLog, CIAO 
Prolog, SWI-Prolog and so on.

================================================================================

Annotation framework
--------------------

The annotation framework provides simple annotations for defining Java 
interfaces for goals. Such an interface is a method annotated by @Goal. The 
formal arguments and the return type of the method can be annotated by @In, 
@Out, @InOut and @NonNull.

Annotations can be used for static type checking and code generation as well.

See below.

================================================================================

Static type checking
--------------------

The checks which can be performed:
  - check the "format string" against the argument types.
  - check the requested variable name (if specified by a literal) against the 
    expected type.
    e.g. aGoalMethod().<String>on("X")
  - ???

================================================================================

Generating goal method body
---------------------------

Goal methods contain only the invocation of the prover. Normally the prover 
associated to the class is to be used, however, the name of the prover should be
able to be specified as the argument of @Goal.

It should be possible to use a quasi empty method body (e.g. throw null;). In 
this case, the invocation of the Prover can be generated at compile time if the 
Sun Java compiler is used. If not, the body can be generated at load time.

The preferred way is to generate them at load-time by a Java agent.

================================================================================

Theories
--------

Theories can be specified by the @Thery specification on types or packages. The 
theory will be added to the prover associated to that type or package, respecti-
vely. Theories should be loaded automatically. The code that adds the theory to 
the appropriate prover can be generated at compile-time if the Sun Java compiler
is used. If not, the theory can be added to the prover at load-time.

The preferred way of loading theories is to load them at the load-time of the 
class or package by a Java agent.

================================================================================

Terms
--------

Term classes can be specified by @Term. The instances of term classes should be 
able to be converted to terms automatically. The way of this should still be 
elaborated. Similarly, if the functor of a compound term equals the name of a 
term class (or the argument of @Term) then the term will be converted to an 
instance of the class. Also, the way of this should be elaborated.
