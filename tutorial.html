<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">











<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Prolog4J - </title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <div id="banner">
                    <span id="bannerLeft">
    
            Prolog4J
    
            </span>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
          
  

  
    
  
  
    
            <div class="xleft">
        Last Published: 2010-03-25
                      </div>
            <div class="xright">      
  

  
    
  
  
    
  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
           
  

  
    
  
  
    
                   <h5>Project Documentation</h5>
            <ul>
              
    <li class="none">
                    <a href="about.html">About</a>
          </li>
              
    <li class="none">
              <strong>Tutorial</strong>
        </li>
              
    <li class="none">
                    <a href="downloads.html">Downloads</a>
          </li>
          </ul>
              <h5>Project Documentation</h5>
            <ul>
              
                
              
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
              
        <li class="collapsed">
                    <a href="project-info.html">Project Information</a>
                </li>
              
                
              
      
            
      
            
      
            
      
              
        <li class="collapsed">
                    <a href="project-reports.html">Project Reports</a>
                </li>
          </ul>
                                           <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
            <img alt="Built by Maven" src="./images/logos/maven-feather.png"></img>
          </a>
                       
  

  
    
  
  
    
        </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Prolog4J Tutorial</h2>
<p>This tutorial contains a fast introduction into the use of Prolog4J.</p>
<div class="section"><h3>Installation</h3>
<p>Download the latest stable version of the Prolog4J API and one of the Prolog4J bindings. The bindings are functionally compatible with each other, but there may be differences between their performance. Moreover, the Prolog4J bindings may allow direct access their wrapped Prolog engine, for the rare case when accessing them through the Prolog4J API is not sufficient for you.</p>
<p>Both the Prolog4J API and one Prolog4J binding has to be added to the class path of your project. Note that adding several bindings to the class path will cause an error message when running the application and Prolog4J will not working.</p>
<p>If you use Maven, add the following repository into the <tt>repositories</tt> section of the <tt>pom.xml</tt>:</p>
<div class="source"><pre>    &lt;repository&gt;
      &lt;id&gt;dev.inf.unideb.hu&lt;/id&gt;
      &lt;name&gt;Archiva Managed Internal Repository&lt;/name&gt;
      &lt;url&gt;http://dev.inf.unideb.hu:8090/archiva/repository/internal/&lt;/url&gt;
      &lt;releases&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
      &lt;/releases&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;</pre>
</div>
<p>The following dependencies are available:</p>
<div class="source"><pre>    &lt;dependency&gt;
      &lt;groupId&gt;org.prolog4j&lt;/groupId&gt;
      &lt;artifactId&gt;prolog4j-api&lt;/artifactId&gt;
      &lt;version&gt;0.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.prolog4j&lt;/groupId&gt;
      &lt;artifactId&gt;prolog4j-tuprolog&lt;/artifactId&gt;
      &lt;version&gt;0.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.prolog4j&lt;/groupId&gt;
      &lt;artifactId&gt;prolog4j-jtrolog&lt;/artifactId&gt;
      &lt;version&gt;0.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.prolog4j&lt;/groupId&gt;
      &lt;artifactId&gt;prolog4j-jlog&lt;/artifactId&gt;
      &lt;version&gt;0.2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.prolog4j&lt;/groupId&gt;
      &lt;artifactId&gt;prolog4j-swi&lt;/artifactId&gt;
      &lt;version&gt;0.2.0&lt;/version&gt;
    &lt;/dependency&gt;</pre>
</div>
<p>Please note that you always have to use the prolog4j-api, but you have to choose exactly one of the bindings.</p>
</div>
<div class="section"><h3>Usage</h3>
<div class="section"><h4>Processing Prolog queries</h4>
<p>You can solve Prolog queries through a <i>prover</i>. Provers can be accessed by the <tt>ProverFactory</tt> class. Prolog queries can be solved by the <tt>solve(String, Object...)</tt> method of a prover. The method returns a <tt>Solution&lt;S&gt;</tt> object using which the solutions of the query can be examined. The solutions are iterable, so they can be iterated over by a for-each loop.</p>
<div class="source"><pre>import org.prolog4j.*;

public class Test {
    public static void main(String[] args) {
        Prover p = ProverFactory.getProver();
        p.loadTheory(&quot;likes.pl&quot;);
        Solution&lt;String&gt; sol = p.solve(&quot;likes(X, peter).&quot;);
        // Does somebody like Peter?
        System.out.println(&quot;Has solution? &quot; + sol.isSuccess());
        // Who likes Peter?
        for (String who: sol) {
            System.out.println(who);
        }
    }
}</pre>
</div>
<p>The type argument of <tt>Solution&lt;S&gt;</tt> denotes the type of the values returned by the solution. Of course, a Prolog goal can contain several variables. At default, the values bound to the last variable of the goal are iterated over. The values are automatically converted to regular Java objects. The type argument of the <tt>Solution</tt> must conform with the values binded to the variable, otherwise you can get <tt>ClassCastException</tt> later. The details of the conversion will be discussed later.</p>
<p>You can specify the name of the argument whose values you are interested of, by the <tt>on(String)</tt> method in the following way:</p>
<div class="source"><pre>        Solution&lt;String&gt; sol = p.solve(&quot;likes(X, peter).&quot;).on(&quot;X&quot;);</pre>
</div>
<p>This is useful when the goal contains several variables and you are not interested of the values of the last one.</p>
<p>If the goal contains several variables, you may be interested of the bindings of more than one at the same time. For this reason, the interators returned by the <tt>Solution&lt;S&gt;</tt> objects implement the <tt>SolutionIterator&lt;S&gt;</tt> interface that provides an additional <tt>get(String)</tt> method to achive the value of any variable of the goal at the steps of the solution finding.</p>
<p>You can see this in the following code sample.</p>
<div class="source"><pre>import org.prolog4j.*;

public class Test {
    public static void main(String[] args) {
        Prover p = ProverFactory.getProver();
        Solution&lt;String&gt; sol = p.solve(&quot;likes(X, Y).&quot;).on(&quot;X&quot;);
        SolutionIterator&lt;String&gt; si = sol.iterator();
        while (si.hasNext()) {
            String x = si.next();
            String y = si.get(&quot;Y&quot;);
            System.out.printf(&quot;%s likes %s.&quot;, x, y);
        }
    }
}</pre>
</div>
</div>
<div class="section"><h4>Passing arguments to queries</h4>
<p>You can pass Java objects to a Prolog query as arguments. The arguments can be specified as additional arguments to the <tt>solve</tt> method, simply. The places of the goal where the arguments has to be substituted into can be denoted by <i>place holders</i>. A place holder is denoted by a question mark, eventually followed by a variable name.</p>
<p>The arguments of the goal get bound to the place holders in the order of their appearance. If you do not want to bind a value to a place holder, you can simply pass <tt>null</tt>.</p>
<p>The use of goal arguments is illustrated by the code sample below. The <tt>likes</tt> method returns the solution for the <tt>likes/2</tt> predicate for the given arguments. Just like the Prolog predicate, the method can also be used for several purposes, depending on whether its arguments are bound or not.</p>
<div class="source"><pre>import org.prolog4j.*;

public class Test {

    private static final Prover p = ProverFactory.getProver();
    static {
        p.loadTheory(&quot;likes.pl&quot;);
    }
    
    public static Solution&lt;String&gt; likes(String x, String y) {
        return p.solve(&quot;likes(?X, ?).&quot;, x, y).on(&quot;X&quot;);
    }
    
    public static void main(String[] args) {
        // Does Susan like Peter?
        System.out.println(likes(&quot;susan&quot;, &quot;peter&quot;).isSuccess());
        // Who likes Peter?
        Solution&lt;String&gt; sol = likes(null, &quot;peter&quot;);
        for (String who: sol) {
            System.out.printf(&quot;%s likes peter.&quot;, who);
        }
        // Who does Peter like?
        sol = likes(&quot;peter&quot;, null);
        for (String who: sol) {
            System.out.printf(&quot;Peter likes %s.&quot;, who);
        }
    }
}</pre>
</div>
</div>
<div class="section"><h4>Preprocessed queries</h4>
<p>You may want to solve the same query at several time for possibly different set of arguments. In this case you can create a <tt>Query</tt> object by the <tt>Prover#query(String)</tt> method. Such queries are stored in a preprocessed way which means that they are parsed by the internal Prolog implementation.</p>
<p>You can solve them at any times later by their <tt>solve(Object...)</tt> method, passing the required arguments.</p>
<div class="source"><pre>import org.prolog4j.*;

public class Test {

    private static final Prover p = ProverFactory.getProver();
    private static final Query LIKES;
    static {
        p.loadTheory(&quot;likes.pl&quot;);
        LIKES = p.query(&quot;likes(?X, ?Y).&quot;);
    }
    
    public static Solution&lt;String&gt; likes(String x, String y) {
        return LIKES.solve(x, y).on(&quot;X&quot;);
    }
    
    public static void main(String[] args) {
        // Does Susan like Peter?
        System.out.println(likes(&quot;susan&quot;, &quot;peter&quot;).isSuccess());
        // Who likes Peter?
        Solution&lt;String&gt; sol = likes(null, &quot;peter&quot;);
        for (String who: sol) {
            System.out.printf(&quot;%s likes peter.&quot;, who);
        }
    }
}</pre>
</div>
<p>If you want to use always the same value for a variable of a query, it is worth binding that value to it before solving it. In this way you do not need to pass that value at every time. Moreover, these <i>pre-bound</i> values are converted only once.</p>
<p>The use of <tt>Query#bind(String, Object)</tt> is illustrated by the following code sample. The example is not very fortunate, because in this case it would be more simple to use 'peter' as an atom directly in the query. However, it is probably easy to imagine a situation when the value is available only at run-time.</p>
<div class="source"><pre>import org.prolog4j.*;

public class Test {

    private static final Prover p = ProverFactory.getProver();
    private static final Query LIKES_PETER;
    static {
        p.loadTheory(&quot;likes.pl&quot;);
        LIKES_PETER = p.query(&quot;likes(?X, ?Y).&quot;);
        LIKES_PETER.bind(&quot;X&quot;, &quot;peter&quot;);
    }
    
    public static Solution&lt;String&gt; likesPeter(String y) {
        return LIKES.solve(y).on(&quot;Y&quot;);
    }
    
    public static void main(String[] args) {
        // Does Susan like Peter?
        System.out.println(likesPeter(&quot;susan&quot;).isSuccess());
        // Who likes Peter?
        Solution&lt;String&gt; sol = likesPeter(null);
        for (String who: sol) {
            System.out.printf(&quot;%s likes peter.&quot;, who);
        }
    }
}</pre>
</div>
</div>
<div class="section"><h4>Conversion policies</h4>
<p>Prolog4J performs automatic conversions between regular Java objects and the objects that represent Prolog terms in the used Prolog backend. The way of conversion is defined by a <i>conversion policy</i>. There is a <i>global conversion policy</i> that can be accessed through the <tt>ProverFactory</tt> class. Besides that every prover has its own policy that relies on the global one at default.</p>
<p>Java numbers (<tt>java.lang.Number</tt>) are converted to Prolog numbers and Java strings (<tt>java.lang.String</tt>) to Prolog atoms, and vice versa. Similarly, Java lists (<tt>java.util.List</tt>) are converted to Prolog lists, and Prolog lists to Java lists. The <tt>null</tt> value is converted to an unbound variable, and unbound variables are converted to <tt>null</tt>. For other variables their value is converted.</p>
<p>Other kinds of objects cannot be converted to terms at default, so you cannot use them as an argument of your queries. For backwards conversion, however, there is a fail-safe class called <tt>Compound</tt>. The compound terms which cannot be converted using the rules above will be converted to a <tt>Compound</tt> object. </p>
<p>You can customize conversion policies (either the global one or the one used by a given prover) by registering your own converters into them. We distinguish <i>term converters</i> and <i>object converters</i>. When you register a term converter, you assign it to an atom. From that time on that converter will be used for that atom and for the compound terms whose functor is that atom.</p>
<p>Regarding the object-term conversion, you can register an object converter to a conversion policy. When you register an object converter, you assign it to a class. From that time on, that converter will be used for the instances of that class. More precisely, when converting an object to a term, the policy will look for a converter registered to its class. If it does not found any, it will look for a converter assigned to one of the supertypes of the object's class. If no suitable converter has been found, an exception is thrown.</p>
<p>The following example illustrates the use of customizing the conversion policies. As you can see, conversion policies provide methods for manipulating terms directly.</p>
<div class="source"><pre>class Human {
        private final String name;
        Human(String name) {
                this.name = name;
        }
        @Override
        public boolean equals(Object obj) {
                return obj instanceof Human &amp;&amp; name.equals(((Human) obj).name);
        }
}
public class Test {
        public static void main(String[] args) {
            Prover p = ProverFactory.getProver();
                final ConversionPolicy cp = p.getConversionPolicy();
                cp.addTermConverter(&quot;human&quot;, new Converter&lt;Object&gt;() {
                        @Override
                        public Object convert(Object term) {
                                if (cp.getArity(term) == 1) {
                                        return new Human((String) cp.getArg(term, 0));
                                }
                                return null;
                        }
                });
                Human socrates = p.&lt;Human&gt;solve(&quot;H=human(socrates).&quot;).get();
                System.out.println(new Human(&quot;socrates&quot;).equals(socrates)); // true

                cp.addObjectConverter(Human.class, new Converter&lt;Human&gt;() {
                        @Override
                        public Object convert(Human human) {
                                return cp.term(&quot;human&quot;, cp.convertObject(human.name));
                        }
                });
                Human plato = new Human(&quot;plato&quot;);
                System.out.println(p.solve(&quot;?=human(plato).&quot;, plato).isSuccess()); // true
        }
}</pre>
</div>
</div>
<div class="section"><h4>Managing a knowledge base</h4>
<p>You can load a Prolog theory from a stream using <tt>Prover#loadTheory(InputStream)</tt>. The result of the method is similar to the <tt>consult/1</tt> predicate.</p>
<p>You can also add a Prolog theory represented as a string, using <tt>Prover#addTheory(String)</tt>. If the theory contains several facts and rules, they can must be separated by new line characters.</p>
<p>If you want to access the same knowledge base from throughout your application, then you have to build that knowledge into a prover, and use that prover from the desired places. To make accessing the required prover easier, provers can be achieved by their <i>name</i> through <tt>ProverFactory#getProver(String)</tt>. This method will create a prover with a given name at the first time it is requested. Later on it will return the same prover for the same name. This mechanism is similar to accessing loggers in logger frameworks.</p>
</div>
</div>
</div>

      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2009-2010
    
          
  

  
    
  
  
    
  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
