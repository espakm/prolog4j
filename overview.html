<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Jan 28, 2011 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Prolog4J - </title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20110128" />
    <meta http-equiv="Content-Language" content="en" />
        
  </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                Prolog4J
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2011-01-28</span>
                  &nbsp;| <span id="projectVersion">Version: 0.2.1-SNAPSHOT</span>
                      </div>
            <div class="xright">        
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                <h5>Project Documentation</h5>
                  <ul>
                  <li class="none">
                          <a href="about.html" title="About">About</a>
            </li>
                  <li class="none">
                          <a href="tutorial.html" title="Tutorial">Tutorial</a>
            </li>
                  <li class="none">
                          <a href="downloads.html" title="Downloads">Downloads</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                                                                                <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                      <li class="collapsed">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>The Prolog4J framework<a name="The_Prolog4J_framework"></a></h2><p>In Section~\ref<a name="sec:embedded">sec:embedded</a> I introduced two Prolog implementations which can be embedded into Java applications in an easy and portable way. These implementations make the interaction possible in both directions between Prolog and Java. Although the communication between the Prolog and Java parts of a program is more fluent than at FLIs, since the type system of the languages is radically different, you still have to convert the objects of your application domain to objects representing Prolog terms and vice versa.</p><p>However, an ideal multiparadigm programming framework or language should allow intermixing the constructs of the languages without forcing the programmer to deal with the internal representation of terms in the system. In the current chapter, I propose a multiparadigm programming framework for Java and Prolog, which do not suffer from this weakness.</p><p>Prolog4J allows running Prolog queries easily from Java. Java types can be mapped into Prolog types, which makes the conversion between Java objects and Prolog terms automatic and natural. Furthermore, using the metadata facility of Java 5, a programming interface can be specified for accessing Prolog rules from Java, through which logic queries can be done with the easiness of method invocations.</p><div class="section"><h3>The Prolog4J Framework<a name="The_Prolog4J_Framework"></a></h3><p>This section describes the Prolog4J Framework, using which you can make Prolog queries from a Java program in an easy way. In contrast with most frameworks, which make it possible to call Prolog code from Java, in Prolog4J there is automatic conversion between Java and Prolog types that makes it possible to use the types of the application domain from both languages.</p><p>The first part of this section present the mapping between the Java and Prolog type systems, based on which the type conversions are automatized. Based on these hidden transformations, the programming interface provides an easy to use way to make Prolog queries and traverse through the solutions. This interface and its use is discussed in Section~\ref<a name="sec:prolog4j_api">sec:prolog4j_api</a>. The third part of the section suggests to extract solving goals into special methods, so-called <i>goal methods</i> so that they can be solved by ordinary method invocations. As you will see, the body of goal methods can be generated based on the metadata facilities of Java. Additionally, goal methods make it also possible to exploit the advantages of static type checking. In the next point I will discuss, how Prolog4J can be used with OOLibrary together to implement some methods in Prolog. Finally, some details of the implementation will be discussed.</p><div class="section"><h4>Automatic conversions<a name="Automatic_conversions"></a></h4><p>The framework has been designed to serve as an interface to a Prolog engine, allowing you to use the reasoning capabilities of Prolog in the application domain of the program. In accordance with this, it was not a goal to transform arbitrary Java objects to Prolog terms. Instead, only the relevant classes of the application domain are allowed to be converted. The current section specifies the conversion only for the most basic cases. The conversion of other types is presented in Section~\ref<a name="sec:termclasses">sec:termclasses</a>.</p><p>With regard to the backwards transformation, the <i>value</i> of any Prolog term can be converted to Java, although there is no Java equivalent of unbound Prolog variables as such. Unbound variables are converted to <tt>null</tt>. Similarly, you can pass <tt>null</tt> if you solve a goal but do not want to bind a value to one of its variables. In case of bound variables, their value is converted.</p><p>Strings, primitive values and their wrapper objects are converted to atomic terms in the same way as described in the tuProlog Guide (Section~6.1) \cite<a name="tuprolog">tuprolog</a>. Arrays and instances of <tt>java.lang.List&lt;E&gt;</tt> are converted to Prolog lists. Table~\ref<a name="table:type_mapping">table:type_mapping</a> summarizes how Java values are converted to tuProlog terms. The types of the first column will be called <i>convertible types</i> later on. Note that there is an auxiliary class <tt>org.prolog4j.Compound</tt>, using which still arbitrary compound terms can be constructed. However, its use is supposed to be as minimal as possible (see Section~\ref<a name="sec:termclasses">sec:termclasses</a> later).</p><p>As you can see, the mapping of tuProlog types to Java types is ambiguous. I denoted with italic letters the default target types at backwards conversions. Atoms (<tt>Struct</tt> objects without arguments) are converted to strings, <tt>Int</tt> objects to <tt>java.lang.Integer</tt> objects. Other <tt>Struct</tt> objects are converted to <tt>List</tt> objects if they represent a Prolog list. Otherwise, an instance of <tt>Compound</tt> will be created.</p><table border="1" class="bodyTable"><caption> Type mapping</caption><tr class="a"><td align="left"><i>Java type</i> (java.lang package)</td><td align="left"><i>tuProlog type</i> (alice.tuprolog package)</td></tr><tr class="b"><td align="left"><tt>char</tt>, <tt>String</tt></td><td align="left"><tt>Struct</tt></td></tr><tr class="a"><td align="left"><tt>byte</tt>, <tt>short</tt>, <tt>int</tt>, <tt>Integer</tt></td><td align="left"><tt>Int</tt></td></tr><tr class="b"><td align="left"><tt>long</tt>, <tt>Long</tt></td><td align="left"><tt>Long</tt></td></tr><tr class="a"><td align="left"><tt>float</tt>, <tt>Float</tt></td><td align="left"><tt>Float</tt></td></tr><tr class="b"><td align="left"><tt>double</tt>, <tt>Double</tt></td><td align="left"><tt>Double</tt></td></tr><tr class="a"><td align="left"><tt>byte[]</tt>, <tt>short[]</tt>, <tt>int[]</tt>, <tt>long[]</tt>, <tt>float[]</tt>, <tt>double[]</tt>, <tt>char[]</tt>, <tt>boolean[]</tt>, <tt>Object[]</tt>, <tt>java.util.List&lt;E&gt;</tt></td><td align="left"><tt>Struct</tt></td></tr><tr class="b"><td align="left"><tt>boolean</tt>, <tt>Boolean</tt></td><td align="left"><tt>Struct</tt> ('true' or 'false')</td></tr><tr class="a"><td align="left"><tt>org.prolog4j.Compound</tt></td><td align="left"><tt>Struct</tt></td></tr></table></div><div class="section"><h4>The Prolog4J API<a name="The_Prolog4J_API"></a></h4><p>In this section I introduce the <tt>Prover</tt> and <tt>Solution&lt;S&gt;</tt> classes and the <tt>SolutionIterator&lt;S&gt;</tt> interface. The types belong to the <tt>org.prolog4j</tt> package. The public API of the types is shown in Fig.~~???.</p><p>Solving a query can be initiated by one of the <tt>solve()</tt> methods of the <tt>Prover</tt> object. (The class is singleton.) Their first argument has to be a goal (String). If a goal should be solved for some specific value of its variables, these values can be passed as additional arguments to the method. If you would not like to bind a value to a variable (used for input/output) you should pass <tt>null</tt> to it. <tt>solve()</tt> methods return a <tt>Solution&lt;S&gt;</tt> object where <tt>S</tt> should be the type of the variable occurring at last in the goal. The methods are generic, the actual type argument to be substituted to <tt>S</tt> is supposed to be specified before the method name at invocation.</p><p>Using a <tt>Solution</tt> instance you can check whether the query is satisfiable (<tt>isSuccess()</tt>), and you can traverse through the solutions if needed. To make this easy, <tt>Solution&lt;S&gt;</tt> implements the <tt>Iterable&lt;S&gt;</tt> interface so that the values bound to the last variable can be walked through simply by a <i>for-each</i> loop. If you would like to walk through the values of another variable, not the last one, you have to call the <tt>on()</tt> generic method of the solution, which will return another <tt>Iterable</tt> object suitable for that.</p><p>Since a query may contain several variables which can get bound during the reasoning, the solutions provide iterators of type <tt>SolutionIterator&lt;S&gt;</tt>. This interface provides additional methods (<tt>get()</tt>) to access the values of the individual variables by their name. The <tt>Solution</tt> class also define <tt>get()</tt> methods that are supposed to be used if you are interested only in the bindings of the first solution, and do not want to find other solutions.</p><p>In some rare cases it may be necessary to pass also the type of a variable to <tt>get()</tt> or <tt>on()</tt>. This is the case when you want to retrieve the value of a list as an array, not as a <tt>java.util.List</tt> object. For this reason these methods have a variant, which can also the type be passed to.</p><p>Finally, the <tt>Solution</tt> class also provides methods for collecting all solutions. These methods take the collection(s), which the solutions has to be collected into, as their argument(s). For convenience, there are special methods to collect solutions into a <tt>Set</tt>, a <tt>List</tt> or an array of lists.</p><div><pre>public class Prover {
  public static Prover get();
  public void addTheory(String... clauses);
  public &lt;A&gt; Solution&lt;A&gt; solve(String goal);
  public &lt;A&gt; Solution&lt;A&gt; solve(String goal, Object... values);
  public &lt;A&gt; Solution&lt;A&gt; solve(String goal, String[] varNames, 
                               Object[] values);
}

public class Solution&lt;S&gt; implements Iterable&lt;S&gt; {
  public boolean isSuccess();

  @Override
  public SolutionIterator&lt;S&gt; iterator();
  public &lt;A&gt; Iterable&lt;A&gt; on(final String argName);
  public &lt;A&gt; Iterable&lt;A&gt; on(final String argName, Class&lt;A&gt; type);
  public &lt;A&gt; Iterable&lt;A&gt; get(final String argName);
  public &lt;A&gt; Iterable&lt;A&gt; get(final String arg, Class&lt;A&gt; type);
  public &lt;C extends Collection&lt;? super S&gt;&gt; C collect(C collection);
  public void collect(Collection... colls);
  public Set&lt;S&gt; toSet();
  public List&lt;S&gt; toList();
  public List&lt;?&gt;[] toLists();
}
public interface SolutionIterator&lt;S&gt; extends Iterator&lt;S&gt; {
  &lt;A&gt; A get(String argName);
}</pre></div><p>The public interface of the Solution class and the SolutionIterator interface</p><p>Fig.~\ref<a name="fig:solution">fig:solution</a> shows examples for their use. <tt>member/2</tt> and <tt>append/3</tt> are ISO Prolog predicates defined by tuProlog. The examples are rather simple, they are only intended to illustrate the basic use of the framework. The first two examples are equivalent with the examples of Fig.~\ref<a name="fig:tuprolog">fig:tuprolog</a>. As you can see, this solution is much more concise and elegant then the one shown in Fig.~\ref<a name="fig:tuprolog">fig:tuprolog</a>. You do not have to bother with constructing the query and converting the result back. No type casts are needed. You even do not need to control the process of finding the solutions.</p><p>The third example checks for the existence of a solution, binding a list to the second variable occuring in the query. The fourth example iterates over the values bound to <tt>X</tt> in the solutions of the same query. The fifth example appends two lists of humans to another. Finally, the last example creates a list (<tt>L2</tt>) which has to be appended to another list (<tt>L1</tt>) to get a third one (<tt>L12</tt>). In the last two examples there is only one solution, which is a list. So, instead of the outer <tt>for</tt> loop this single solution could have been accessed simply by <tt>get()</tt>. Note that there are no type casts in the examples.</p><div><pre>public class Prolog4JTest {
  private static final Prover p = Prover.get();
  static {
    p.addTheory(&quot;mortal(X) :- human(X).&quot;,\
         &quot;human(socrates).&quot;, &quot;human(plato).&quot;);  }
  public static boolean isMortal(String somebody) {
    return p.solve(&quot;mortal(X).&quot;, somebody).isSuccess();
  }
  public static List&lt;String&gt; getMortals() {
    List&lt;String&gt; mortals = new ArrayList&lt;String&gt;();
    for (String s: p.&lt;String&gt;solve(&quot;mortal(X).&quot;))
      mortals.add(s);
    return mortals;
  }
  public static void main(String[] args) {
    System.out.println(isMortal(&quot;socrates&quot;)); // true
    System.out.println(getMortals());      // socrates, plato
    
    List&lt;String&gt; philosophers = Arrays.asList(&quot;socrates&quot;, &quot;plato&quot;);
    Solution&lt;?&gt; solution = 
      p.solve(&quot;member(X, List).&quot;, null, philosophers);
    System.out.println(solution.isSuccess()); // true

    for (String s: solution.&lt;String&gt;on(&quot;X&quot;))
      System.out.println(s);               // socrates, plato

    List&lt;String&gt; h1 = Arrays.asList(&quot;socrates&quot;);
    List&lt;String&gt; h2 = Arrays.asList(&quot;thales&quot;, &quot;plato&quot;);
    for (List&lt;String&gt; humans: 
        p.&lt;List&lt;String&gt;&gt;solve(&quot;append(L1, L2, L12).&quot;, h1, h2))
      for (String h: humans)
        System.out.println(h);             // socrates, thales and plato

    List&lt;String&gt; h3 = Arrays.asList(&quot;socrates&quot;, &quot;homeros&quot;, &quot;demokritos&quot;);
    for (List&lt;String&gt; humans: p.solve(&quot;append(L1, L2, L12).&quot;, h1,null,h3)
         .&lt;List&lt;String&gt;&gt;on(&quot;L2&quot;))
      for (String h: humans)
        System.out.println(h);             // homeros and demokritos
  }}</pre></div><p>Applying rules from Java</p></div><div class="section"><h4>Annotations<a name="Annotations"></a></h4><p>The use of the framework can be made even more simple and safe using the metadata facility of Java \cite<a name="metadata">metadata</a>. Using the annotations presented in this section the prover does not require to be referred to directly, and some more checks can be performed statically.</p><p>Prolog theories can be specified by the <tt>@Theory</tt> annotation. The argument of <tt>@Theory</tt> is an array of strings, the elements of which represent Prolog clauses. The annotation is processed at load time.</p><p>As discussed in the Section~\ref<a name="sec:prolog4j_api">sec:prolog4j_api</a>, Prolog goals can be solved by <tt>Prover</tt>. When a goal has to be solved several times, it is suggested to define a method for that which makes its use even more simpler. The body of such methods can also be generated by specifying the <tt>@Goal</tt> annotation for the method. These methods will be called <i>goal methods</i> later on. The goal itself can be defined as the default argument of the annotation (<tt>value</tt>).</p><p>Goal methods can expect arguments of convertible types as discussed in Section~\ref<a name="sec:convertible_types">sec:convertible_types</a>. The return type of goal methods can be one of the followings:</p><ul><li><tt>boolean</tt> or <tt>java.lang.Boolean</tt> if you are interested only in the satisfiability of the goal, * a convertible type if you are interested only in the first solution (or no more solutions are possible) and there is only one output variable whose value important, * <tt>Solution&lt;S&gt;</tt>, where <tt>S</tt> is the type of an <i>output</i> variable. Using the returned <tt>Solution</tt> object, the solutions of a query can be traversed through.<p>The formal arguments can be annotated by <tt>@In</tt> or <tt>@InOut</tt>, denoting input or input/output arguments, respectively. They can be omitted, the default is <tt>@In</tt>. The name of the variable in the goal, which the formal argument has to be bound to, can be specified as an argument of these annotations. In default, the arguments bind to the variables in the order of their appearance. ~~ For now, only <tt>@In</tt> is processed by the tool. <tt>@Out</tt> serves only documentation purposes now, but later it could also be used for static type checking.</p><p>The return type (if not <tt>boolean</tt> or <tt>Boolean</tt>) can be annotated by <tt>@Out</tt> \footnote<a name="In_fact_the_annotation_belongs_not_to_the_return_type_but_the_method_although_formally_it_can_also_be_written_after_the_modifiers_directly_before_the_return_type.">In fact, the annotation belongs not to the return type but the method, although formally it can also be written after the modifiers, directly before the return type.</a>, which makes it possible to specify the name of the output variable. If not specified, the value of the last variable will be returned.</p><p>F&#xe4;hndrich and Leino showed how an object-oriented language such as Java or C\# could be extended with <i>non-null types</i> \cite<a name="nonnull">nonnull</a>. Non-null types provide a type-based approach to detect possible null pointer violations in code statically at compile time. Java Specification Request 308 (JSR-308) \cite<a name="jsr308">jsr308</a> proposes an extension to Java's annotation system that permits annotations to appear on nearly any use of a type. (By contrast, Java SE 6 permits annotations only on class/method/field/variable declarations.) Using the extended syntax of JSR-308 the <tt>@NonNull</tt> annotation can be specified for any reference type. There are prototype implementations available for JSR-308 and the nullness checker \cite<a name="JastAddNonNull">JastAddNonNull</a>. The changes proposed by JSR-308 are planned to be part of the Java 7 language.</p><p>The <tt>@NonNull</tt> annotation can be used later (from Java 7 on) to specify <i>ground</i> input arguments. This way such situations could be prevented by static type checking where a ground input argument of a goal method would get a <tt>null</tt> value.</p><p>The body of rule methods can be arbitrary (e.g.&#160;<tt><a name="throw_null"> throw null; </a></tt>), because it will be replaced during the annotation processing. Fig.~\ref<a name="fig:goals">fig:goals</a> shows an example for the use of Prolog4J annotations. The example is borrowed \cite<a name="pj">pj</a>, the original version is shown in Fig.~\ref<a name="fig:pj_goals">fig:pj_goals</a>. As you can see the Prolog4J version is much more concise, without loosing the expressiveness and type safety of P@J.</p><p>At this point it makes sense to specify static goal methods only. However, <i>term classes</i>, which are the topic of the next part of the section, may also have non-static goal methods.</p><div><pre>@Theory({
  &quot;remove([X|Xs],X,Xs).&quot;,
  &quot;remove([X|Xs],E,[X|Ys]):-remove(Xs,E,Ys).&quot;,
  &quot;permutation([],[]).&quot;,
  &quot;permutation(Xs,[X|Ys]):-remove(Xs,X,Zs), permutation(Zs,Ys).&quot;})
public class PermutationTest {
  @Goal(&quot;remove(X, Y, Z).&quot;)
  static List&lt;Integer&gt; remove(List&lt;Integer&gt; list, Integer i) { throw null; }

  @Goal(&quot;permutation(X, Y).&quot;)
  static @Out(&quot;Y&quot;) Solution&lt;List&lt;Integer&gt;&gt; perms(@In(&quot;X&quot;) List&lt;Integer&gt; list){
    throw null;}
  public static void main(String[] args) {
     List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);
     for (List&lt;Integer&gt; li: perms(list))
       System.out.println(Collections.max(li));
  }
}</pre></div><p>Defining goal methods in Prolog4J</p><div><pre>@PrologClass (
    clauses = {&quot;remove([X|Xs],X,Xs).&quot;,
               &quot;remove([X|Xs],E,[X|Ys]):-remove(Xs,E,Ys).&quot;,
               &quot;permutation([],[]).&quot;,
               &quot;permutation(Xs,[X|Ys]):-remove(Xs,X,Zs), permutation(Zs,Ys).&quot;})
public abstract class PermutationUtility {
  @PrologMethod (link=&quot;remove($1,$2,$0)&quot;,
                  style=PrologInvocationKind.FUNCTIONAL)
  abstract @GROUND List&lt;Int&gt; remove(@INPUT @GROUND List&lt;Int&gt; c1,
                                      @INPUT @GROUND Int i);
  @PrologMethod (link=&quot;permutation(@1,@2)&quot;,
                  multipleOutput=true,
                  style=PrologInvocationKind.RELATIONAL)
  abstract @GROUND Iterable&lt;Compound1&lt;List&lt;Int&gt;&gt;&gt; perms(
           @HIDE @INPUT @GROUND List&lt;Int&gt; c1, @OUTPUT @GROUND Var&lt;List&lt;Int&gt;&gt; c2);
  public static void main(String[] args) throws Exception{
     PermutationUtility pu = Java2Prolog.newInstance(PermutationUtility.class);
     java.util.Collection&lt;Integer&gt; l=new java.util.LinkedList&lt;Integer&gt;();
     l.add(1); l.add(2); l.add(3);
     Var&lt;List&lt;Int&gt;&gt; x = new Var&lt;List&lt;Int&gt;&gt;(&quot;X&quot;);
     List&lt;Int&gt; list = Term.fromJava(l);
     for (Compound1&lt;List&lt;Int&gt;&gt; compound : pu.perms(list,x)) {
       Collection&lt;Integer&gt; ci = compound.get0().toJava();
       System.out.println(Collections.max(li));
     }
  }
}</pre></div><p>Defining Prolog methods in P@J \cite<a name="pj">pj</a></p></li></ul></div><div class="section"><h4>Term classes<a name="Term_classes"></a></h4><p>The set of convertible types discussed in Section~\ref<a name="sec:convertible_types">sec:convertible_types</a> is rather poor. To allow to reason about the objects of your application domain, <i>term classes</i> can be defined. Term classes are also regarded as convertible types. A class can be declared a term class by annotating it with <tt>@org.prolog4j.Term</tt>. The annotation is inherited, so annotating a class with it causes that its subclasses will be term classes as well.</p><p>Processing <tt>@Term</tt> relies on OOLibrary. An OOLibrary class definition is generated from term classes. </p><p>As noted in \ref<a name="sec:annotations">sec:annotations</a>, term classes, may also have non-static goal methods. In this case the actual object (<tt>this</tt>) will be bound to the variable called <tt>This</tt> that is regarded as an input only argument.</p><div><pre>@Term
public class Human {
  private String name;
  public Human(String name) { this.name = name; }

  public static void main(String[] args) {
    System.out.println(isMortal(&quot;socrates&quot;)); // true
    System.out.println(getMortals());      // socrates, plato
    
    List&lt;String&gt; philosophers = Arrays.asList(&quot;socrates&quot;, &quot;plato&quot;);
    Solution&lt;?&gt; solution = p.solve(&quot;member(X, List).&quot;,null,philosophers);
    System.out.println(solution.isSuccess()); // true

    for (String s: solution.&lt;String&gt;on(&quot;X&quot;))
      System.out.println(s);               // socrates, plato

    List&lt;Human&gt; h1 = Arrays.asList(new Human(&quot;socrates&quot;));
    List&lt;Human&gt; h2=Arrays.asList(new Human(&quot;thales&quot;),new Human(&quot;plato&quot;));
    for (List&lt;Human&gt; humans: 
        p.&lt;List&lt;Human&gt;&gt;solve(&quot;append(L1, L2, L12).&quot;, h1, h2))
      for (Human h: humans)
        System.out.println(h.name);        // socrates, thales and plato

    List&lt;Human&gt; h3 = Arrays.asList(new Human(&quot;socrates&quot;),
        new Human(&quot;homeros&quot;), new Human(&quot;demokritos&quot;));
    for (List&lt;Human&gt; humans: p.solve(&quot;append(L1, L2, L12).&quot;, h1,null,h3).
          &lt;List&lt;Human&gt;&gt;on(&quot;L2&quot;))
      for (Human h: humans)
        System.out.println(h.name);        // homeros and demokritos
  }
}</pre></div><p>Applying rules from Java</p></div><div class="section"><h4>Implementation<a name="Implementation"></a></h4><p>The specification of methods annotated with <tt>@Goal</tt> contains every information to construct a <tt>Solution</tt> object. The body for these methods are generated at compile time. The annotations are processed by the Pluggable Annotations Framework \cite<a name="plug">plug</a> of Java 6. Although this framework does not provide means for code generation directly, it gives an environment, through which the whole compiler tree can be manipulated \cite<a name="comptree">comptree</a>. Unfortunately this feature works only with the Sun's Java compilers. tuProlog terms that represent a goal and its input variables are created at the first time the method is invoked then they are cached in a private static field of their class.</p><p>If <tt>@In</tt>, <tt>@Out</tt> or <tt>@InOut</tt> is specified in a goal method, the compile-time annotation processor verifies whether parameters of the annotations occur in the Prolog query.</p></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">Copyright &#169;                   2009-2011.
          All Rights Reserved.      
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
